# Overall, this file includes the function get_all_row_ids_to_upcode as well as two helper
# functions: get_row_ids_to_upcode_for_single_hcc and format_upcoding_row_ids_to_tibble. The
# two helper functions respectively sample the available data for which rows to upcode for one
# HCC (e.g. column), and format_upcoding_row_ids_to_tibble formats the row_ids to upcode across
# timepoints into a tibble for easier lookup later.

#' Get all row IDs to upcode for all HCCs specified in upcoding_spec_df
#'
#' For each HCC, this samples (without replacement) a list of row indexes to upcode from the
#' overall dataset, so that the user-specified upcoding proportion and approach
#' occurs.
#'
#' @param upcoding_spec_df (tibble or dataframe) Tibble or data frame specifying which HCCs to upcode and how. This
#'   is expected to have columns 'hcc' (containing any of the v28 HCCs), 'approach'
#'   (either 'any' or 'lower severity' are allowed), and 'upcoding_prop' (must be a proportion
#'   greater than 0 and less than 1)
#' @param curr_dt (data.table) Binary data.table with rows corresponding to people and
#'   columns corresponding to 115 HCCs (from v28 of CMS-HCC) and one column for
#'   person_ids. If it has not been modified already, this is generated by simulate_baseline_v28_data
#' @param num_timepoints (int) The number of timepoints across which to censor sets of beneficiaries
#'
#' @return A tibble of row IDs to upcode for each HCC in upcoding_spec_df across the number of timepoints specified
#'
#' @export
get_all_row_ids_to_upcode <- function(
    upcoding_spec_df,
    curr_dt,
    num_timepoints) {
  spec_dt <- data.table::as.data.table(upcoding_spec_df)

  # Process all HCCs
  spec_dt[,
    row_ids := list(list(
      get_row_ids_to_upcode_for_single_hcc(
        hcc = hcc,
        approach = approach,
        upcoding_prop = upcoding_prop,
        curr_dt = curr_dt
      )
    )),
    by = seq_len(nrow(spec_dt))
  ]

  # Split row IDs into timepoints
  spec_dt[,
    row_id_splits := list(list(
      if (length(row_ids[[1]]) == 0) {
        lapply(seq_len(num_timepoints), function(x) integer(0))
      } else {
        split_row_ids_into_timepoints(row_ids[[1]], num_timepoints)
      }
    )),
    by = seq_len(nrow(spec_dt))
  ]

  all_upcoding_row_id_tbl <- format_upcoding_row_ids_to_tibble(
    spec_dt$row_id_splits,
    upcoding_spec_df
  )

  return(all_upcoding_row_id_tbl)
}

# gets indexes of rows to upcode for a single HCC
get_row_ids_to_upcode_for_single_hcc <- function(
    hcc,
    approach,
    upcoding_prop,
    curr_dt) {
  if (!tolower(approach) %in% c("any", "lower severity")) {
    stop("Approach must be either 'any' or 'lower severity' only")
  }

  if (upcoding_prop <= 0 | upcoding_prop >= 1) {
    stop("upcoding_prop must be between 0 and 1")
  }

  if (tolower(approach) == "any") {
    eligible_rows <- curr_dt[get(hcc) == 0, person_id]
    n_to_sample <- floor(length(eligible_rows) * upcoding_prop)
    if (n_to_sample > 0) {
      sampled_ids <- sample(eligible_rows, n_to_sample)
    } else {
      sampled_ids <- integer(0)
    }
  } else {
    # Get lower severity HCCs
    lower_severity_hccs <- unlist(hcc_hierarchy_list[[hcc]], use.names = FALSE)

    if (length(lower_severity_hccs) > 0) {
      has_lower <- curr_dt[,
        rowSums(.SD) > 0,
        .SDcols = intersect(lower_severity_hccs, names(curr_dt))
      ]
      eligible_rows <- curr_dt[has_lower & get(hcc) == 0, person_id]
    } else {
      eligible_rows <- integer(0)
    }

    n_to_sample <- floor(length(eligible_rows) * upcoding_prop)
    if (n_to_sample > 0) {
      sampled_ids <- sample(eligible_rows, n_to_sample)
    } else {
      sampled_ids <- integer(0)
    }
  }

  return(sampled_ids)
}

# formats the row_ids to upcode across all timepoints into a tibble for easier lookup later
format_upcoding_row_ids_to_tibble <- function(
    all_upcoding_row_id_splits,
    upcoding_spec_df) {
  n_hccs <- length(all_upcoding_row_id_splits)
  n_timepoints <- length(all_upcoding_row_id_splits[[1]])

  total_rows <- n_hccs * n_timepoints

  hcc_vec <- character(total_rows)
  timepoint_vec <- integer(total_rows)
  row_ids_vec <- vector("list", total_rows)

  idx <- 1
  for (i in seq_len(n_hccs)) {
    hcc <- upcoding_spec_df$hcc[i]
    splits <- all_upcoding_row_id_splits[[i]]

    for (j in seq_len(n_timepoints)) {
      hcc_vec[idx] <- hcc
      timepoint_vec[idx] <- j
      row_ids_vec[[idx]] <- splits[[j]]
      idx <- idx + 1
    }
  }

  tibble::tibble(
    row_ids = row_ids_vec,
    hcc = hcc_vec,
    timepoint = timepoint_vec
  )
}
