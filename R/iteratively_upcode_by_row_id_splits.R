# Overall, this file contains the function iteratively_upcode_by_row_id_splits as well as
# a helper function check_which_row_ids_remain_coded. check_which_row_ids_remain_coded helps
# by removing rows that were censored or set to zero by calling apply_v28_hierarchy
# so that they are not included in the output of row IDs that were upcoded by timepoint.

#' Upcode an individual HCC across at a given timepoint
#'
#' This function calls upcode_hcc_by_row_ids iteratively for each user-specified
#' timepoint. At each timepoint, the v28 CMS-HCC hierarchy is applied and the
#' data at that timepoint is written to file.
#'
#' @importFrom tibble tibble
#'
#' @param curr_dt (data.table, also accepts tibble or dataframe) The data.table to upcode. This is a binary data.table with
#' rows corresponding to people and columns corresponding to 115 HCCs (from v28 of CMS-HCC) and one column for
#'   person_ids. If it has not been modified already, this is generated by simulate_baseline_v28_data
#' @param all_upcoding_row_id_tbl (tibble, also accepts dataframe) Tibble of all row ids upcode across all time points
#' @param censoring_row_id_tbl (tibble, also accepts dataframe) Tibble of all row ids to right censor across all time points
#' @param curr_hcc (string) The HCC (e.g. column to upcode in the format "hccXXX")
#' @param out_dir (string) Directory to write each time point's upcoded data
#' @param out_file_prefix (string) Prefix to use for each time point's upcoded data
#' @param apply_v28_hierarchy (boolean, Default: FALSE) Whether to apply the v28 hierarchy to the data after upcoding
#' @param all_censored_ids (integer vector, Default: NULL) Optional vector of person IDs that will be censored across all HCCs. When provided, ensures event labels don't include person IDs that will be removed by censoring in other HCC processing.
#'
#' @export
iteratively_upcode_by_row_id_splits <- function(
    curr_dt,
    all_upcoding_row_id_tbl,
    censoring_row_id_tbl,
    curr_hcc,
    out_dir,
    out_file_prefix,
    apply_v28_hierarchy,
    all_censored_ids = NULL) {
  # Cast to data.table
  data.table::setDT(curr_dt)

  # Check if out_dir exists and make if needed
  if (!dir.exists(here::here(out_dir))) {
    dir.create(here::here(out_dir), recursive = TRUE)
  }

  upcode_dt <- data.table::as.data.table(all_upcoding_row_id_tbl)
  hcc_upcode <- upcode_dt[hcc == curr_hcc]

  timepoint_row_ids <- list()
  for (i in seq_len(nrow(hcc_upcode))) {
    t <- hcc_upcode$timepoint[i]
    timepoint_row_ids[[as.character(t)]] <- unlist(hcc_upcode$row_ids[i])
  }

  if (!is.null(censoring_row_id_tbl)) {
    censor_timepoints <- unique(censoring_row_id_tbl$timepoint)
  } else {
    censor_timepoints <- NULL
  }
  unique_timepoints <- sort(unique(hcc_upcode$timepoint))

  all_events <- list()
  event_count <- 0

  for (t in unique_timepoints) {
    # Upcode current HCC at current time point
    upcode_hcc_by_row_ids(curr_dt, all_upcoding_row_id_tbl, curr_hcc, t)

    # Censor IDs at current time point if they are listed
    if (!is.null(censor_timepoints)) {
      if (t %in% censor_timepoints) {
        censor_by_row_ids(curr_dt, censoring_row_id_tbl, t)
      }
    }

    # Apply CMS-HCC v28 hierarchy if specified
    if (apply_v28_hierarchy == TRUE) {
      apply_v28_cmshcc_hierarchy(curr_dt)
    }

    curr_row_ids <- timepoint_row_ids[[as.character(t)]]
    if (length(curr_row_ids) > 0) {
      coded_mask <- curr_dt[[curr_hcc]] == 1
      coded_ids <- curr_dt$person_id[coded_mask]

      upcoded_mask <- curr_row_ids %in% coded_ids
      upcoded_row_ids <- curr_row_ids[upcoded_mask]

      if (length(upcoded_row_ids) > 0) {
        event_count <- event_count + 1
        all_events[[event_count]] <- list(
          person_id = upcoded_row_ids,
          event_type = rep(1L, length(upcoded_row_ids)),
          event_time = rep(t, length(upcoded_row_ids))
        )
      }
    }
  }

  if (event_count > 0) {
    person_ids <- unlist(lapply(all_events, `[[`, "person_id"))
    event_types <- unlist(lapply(all_events, `[[`, "event_type"))
    event_times <- unlist(lapply(all_events, `[[`, "event_time"))

    events_dt <- data.table::data.table(
      person_id = person_ids,
      event_type = event_types,
      event_time = event_times
    )
  } else {
    events_dt <- data.table::data.table(
      person_id = integer(0),
      event_type = integer(0),
      event_time = integer(0)
    )
  }

  # Add no-event IDs
  no_event_ids <- setdiff(curr_dt$person_id, events_dt$person_id)
  if (length(no_event_ids) > 0) {
    no_events_dt <- data.table::data.table(
      person_id = no_event_ids,
      event_type = 0L,
      event_time = max(unique_timepoints)
    )
    events_dt <- rbind(events_dt, no_events_dt)
  }

  # If we know which IDs will be censored (when called from upcode_all_hccs),
  # ensure that only person IDs that won't be removed by censoring in later HCC processing
  # are marked as having the event
  if (!is.null(all_censored_ids) && length(all_censored_ids) > 0) {
    # Check which person IDs with event_type = 1 are in the censored list
    # These are person IDs that were upcoded but will be removed when processing other HCCs
    events_dt[
      person_id %in% all_censored_ids & event_type == 1,
      event_type := 0L
    ]
  }

  # Write event labels and times to file
  label_df <- tibble::tibble(
    person_id = events_dt$person_id,
    event_type = events_dt$event_type,
    event_time = events_dt$event_time
  )

  readr::write_csv(
    label_df,
    here::here(paste(
      out_dir,
      paste(
        curr_hcc,
        paste(
          paste(out_file_prefix, "event_and_time_labels", sep = "_"),
          ".csv",
          sep = ""
        ),
        sep = "_"
      ),
      sep = "/"
    ))
  )
}

check_which_row_ids_remain_coded <- function(
    curr_dt,
    all_upcoding_row_id_tbl,
    curr_hcc,
    t) {
  # Get row IDs that were supposed to be upcoded at current time point
  curr_row_ids_to_upcode <- all_upcoding_row_id_tbl |>
    dplyr::filter(hcc == curr_hcc & timepoint == t) |>
    tidyr::unnest(row_ids) |>
    dplyr::pull(row_ids)

  if (length(curr_row_ids_to_upcode) == 0) {
    return(integer(0))
  }

  coded_person_ids <- curr_dt[get(curr_hcc) == 1, person_id]

  intersect(curr_row_ids_to_upcode, coded_person_ids)
}
