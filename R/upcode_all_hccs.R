#' Upcodes all user-specified HCCs to a user-specified overall proportion and
#' approach, across a user-specified number of time points.
#'
#' This function expects users to indicate their preferences through a tibble
#' (upcoding_spec_df), which is checked for correct formatting in the function. This
#' generates and writes two output files: (1) all_hcc_upcoded_data.csv, which corresponds
#' to the final upcoded and censored data at the end of all time points, and
#' (2) (hcc_name)_upcoded_data_event_and_time_labels.csv, which is a tibble with columns
#' `person_id`, `event_type`, and `event_time` with labeled upcoding events by time point.
#'
#' @importFrom here here
#'
#' @param curr_dt ((data.table; also accepts data.frame or tibble) The data.table to upcode. This is a binary data.table with
#' rows corresponding to people and columns corresponding to 115 HCCs (from v28 of CMS-HCC) and one column for
#'   person_ids. If it has not been modified already, this is generated by simulate_baseline_v28_data
#' @param upcoding_spec_df (tibble or dataframe) Tibble or data frame specifying which HCCs to upcode and how. This
#'   is expected to have columns 'hcc' (containing any of the v28 HCCs), 'approach'
#'   (either 'any' or 'lower severity' are allowed), and 'upcoding_prop' (must be a proportion
#'   greater than 0 and less than 1)
#' @param out_dir (string) The directory to which to write output
#' @param censoring_prop (float, Default: 0.05) The proportion of beneficiaries to
#'   censor overall (across all timepoints).
#' @param num_timepoints (int, Default: 4) The number of time periods over which all
#'   upcoding or censoring is implemented. This function will randomly distribute the indexes to
#'   upcode across these time points.
#' @param apply_v28_hierarchy (boolean, Default: FALSE) Whether to apply the v28 hierarchy to the data after upcoding
#' @param out_file_prefix (string, Default: "upcoded_data") Prefix of output upcoded
#'   files
#' @param curr_seed (int, Default: 123) Seed for upcoding
#' @export
upcode_all_hccs <- function(
    curr_dt,
    upcoding_spec_df,
    out_dir,
    censoring_prop = 0.05,
    num_timepoints = 4,
    apply_v28_hierarchy = FALSE,
    out_file_prefix = "upcoded_data",
    curr_seed = 123) {
  withr::local_seed(curr_seed)

  # Cast to data.table
  data.table::setDT(curr_dt)

  # Check upcoding_spec_df is formatted correctly
  check_upcoding_spec_df_colnames(upcoding_spec_df)

  # Check curr_dt is formatted correctly
  check_curr_dt(curr_dt)

  # Check if out_dir exists and make if needed
  if (!dir.exists(here::here(out_dir))) {
    dir.create(here::here(out_dir), recursive = TRUE) # Also make parent directories if needed
  }

  # Get all row IDs to censor at each time point
  censoring_row_id_tbl <- get_all_row_ids_to_censor(
    curr_dt,
    num_timepoints,
    censoring_prop
  )

  # Get all row IDs to upcode for each HCC and each timepoint
  upcoding_row_id_tbl <- get_all_row_ids_to_upcode(
    upcoding_spec_df,
    curr_dt,
    num_timepoints
  )

  # Get all person IDs that will be censored across all timepoints
  if (!is.null(censoring_row_id_tbl) && nrow(censoring_row_id_tbl) > 0) {
    all_censored_ids <- unique(unlist(censoring_row_id_tbl$row_ids))
  } else {
    all_censored_ids <- integer(0)
  }

  # Upcode each HCC for timepoints specified
  sapply(upcoding_spec_df$hcc, function(h) {
    iteratively_upcode_by_row_id_splits(
      curr_dt,
      upcoding_row_id_tbl,
      censoring_row_id_tbl,
      h,
      out_dir,
      out_file_prefix,
      apply_v28_hierarchy,
      all_censored_ids
    )
  })

  # Write final upcoded matrix of all HCCs to file
  out_path <- fs::path(here::here(
    out_dir,
    paste("all_hcc", paste(out_file_prefix, ".csv", sep = ""), sep = "_")
  ))
  readr::write_csv(
    curr_dt,
    out_path
  )
}
