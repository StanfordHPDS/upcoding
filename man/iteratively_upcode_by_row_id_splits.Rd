% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iteratively_upcode_by_row_id_splits.R
\name{iteratively_upcode_by_row_id_splits}
\alias{iteratively_upcode_by_row_id_splits}
\title{Upcode an individual HCC across at a given timepoint}
\usage{
iteratively_upcode_by_row_id_splits(
  curr_dt,
  all_upcoding_row_id_tbl,
  censoring_row_id_tbl,
  curr_hcc,
  out_dir,
  out_file_prefix,
  apply_v28_hierarchy,
  all_censored_ids = NULL
)
}
\arguments{
\item{curr_dt}{(data.table, also accepts tibble or dataframe) The data.table to upcode. This is a binary data.table with
rows corresponding to people and columns corresponding to 115 HCCs (from v28 of CMS-HCC) and one column for
person_ids. If it has not been modified already, this is generated by simulate_baseline_v28_data}

\item{all_upcoding_row_id_tbl}{(tibble, also accepts dataframe) Tibble of all row ids upcode across all time points}

\item{censoring_row_id_tbl}{(tibble, also accepts dataframe) Tibble of all row ids to right censor across all time points}

\item{curr_hcc}{(string) The HCC (e.g. column to upcode in the format "hccXXX")}

\item{out_dir}{(string) Directory to write each time point's upcoded data}

\item{out_file_prefix}{(string) Prefix to use for each time point's upcoded data}

\item{apply_v28_hierarchy}{(boolean, Default: FALSE) Whether to apply the v28 hierarchy to the data after upcoding}

\item{all_censored_ids}{(integer vector, Default: NULL) Optional vector of person IDs that will be censored across all HCCs. When provided, ensures event labels don't include person IDs that will be removed by censoring in other HCC processing.}
}
\description{
This function calls upcode_hcc_by_row_ids iteratively for each user-specified
timepoint. At each timepoint, the v28 CMS-HCC hierarchy is applied and the
data at that timepoint is written to file.
}
